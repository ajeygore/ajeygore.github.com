<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How VPN automation ended up becoming a Single Sign On Server — Part 2</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How VPN automation ended up becoming a Single Sign On Server — Part 2</h1>
</header>
<section data-field="subtitle" class="p-summary">
In part 1 of this blog, we covered the process of how we used an OpenVPN server to authenticate with our rest based Gate service by hitting…
</section>
<section data-field="body" class="e-content">
<section name="f73d" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="18ea" id="18ea" class="graf graf--h3 graf--leading graf--title">How VPN automation ended up becoming a Single Sign On Server — Part 2</h3><p name="095d" id="095d" class="graf graf--p graf-after--h3">In part 1 of this blog, we covered the process of how we used an OpenVPN server to authenticate with our rest based Gate service by hitting a URL with username and MFA token. But in order to address the issue of users accessing our portals, we needed to turn to CAS to find a solution. We will cover the approach that we used, in this blog.</p><h4 name="3966" id="3966" class="graf graf--h4 graf-after--p">Integrating CAS with rest based MFA system</h4><p name="5ed0" id="5ed0" class="graf graf--p graf-after--h4">At this time, the JaSig CAS community was implementing MFA support, but it wasn’t what we wanted. We wanted a simpler and more usable solution, and they were not looking to support Google MFA. What we needed was a custom authentication handler which can take user name and token, talk to our service over http and authenticate.</p><p name="86f3" id="86f3" class="graf graf--p graf-after--p">We took a dirty shortcut and implemented a custom authentication handler. This would take the Gate server’s address from an environment variable and try to hit the URL with user name and password. After experimenting with this for a day, we ended up writing the <a href="https://github.com/gate-sso/cas_gate" data-href="https://github.com/gate-sso/cas_gate" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">first module for our rest based server</a>. A single file, and our job was done.</p><p name="b54b" id="b54b" class="graf graf--p graf-after--p">Now the portals that had the concept of users, could integrate with it using a simple SAML implementation. For portals that didn’t, we turned to Apache CAS integrations. The Apache HTTP server protected the portals and asked users to authenticate using “Gate”.</p><p name="b72d" id="b72d" class="graf graf--p graf-after--p">But we still had one issue: Login to our servers. There are many solutions to this. A typical configuration management system allows you to grant access to specific users to specific servers. Or you can use LDAP to centralize this. Our first hunch was to just go and implement an LDAP server — and then use <em class="markup--em markup--p-em">pam_ldap</em> and <em class="markup--em markup--p-em">nss_ldap</em> with <em class="markup--em markup--p-em">mkhomedir.so</em>. But while implementing LDAP, we realised that we needed to sync those users, and while we could allow them to upload their ssh public key to ldap and then centralize auth, it was still a cumbersome process.</p><p name="e586" id="e586" class="graf graf--p graf-after--p">A second approach came up. We thought, “Why not sync all Gate’s active users to LDAP, have a UI to upload public key to gate and sync that with LDAP?”. The idea worked and we could do that pretty easily; but LDAP was still in between, and if the sync did not happen immediately, the user would be left out of the Linux system. To work around this, we wrote a ‘hook’ : whenever there was change in the public key, it would go and write to LDAP. However, this was still a roundabout way and not very clean. While it did not make any difference to user, we had one more systems to take care of, behind the scenes.</p><p name="65cf" id="65cf" class="graf graf--p graf-after--p">That is when we had the brainwave of writing a PAM module and NSS module to authenticate and lookup users in the Linux system. With a little bit of research, we found out that newer versions of SSH provide AuthorizedKeysCommand and AuthorizedKeysUser combinations to hookup any script, which can provide a public key for a user name given as argument to AuthorizedKeysCommand.</p><p name="7447" id="7447" class="graf graf--p graf-after--p">So, if we could provide all Gate’s users to the Linux systems and then provide their public keys based on user names, then we could remove LDAP in the middle.</p><p name="76ab" id="76ab" class="graf graf--p graf-after--p">A quick google search revealed that people had already done some experiments around this, but they were not very generic. Moreover, their code did reference implementation. We got excited about the possibility of writing <strong class="markup--strong markup--p-strong">nss </strong>and <strong class="markup--strong markup--p-strong">pam </strong>modules with SSH Integration — those can lookup the user, group and shadow information from a web server, authenticate user with web server and lookup the public key as well.</p><p name="0873" id="0873" class="graf graf--p graf-after--p">Now the problem statement became very clear.</p><blockquote name="db7b" id="db7b" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Provide a system which allows any Linux server to lookup a user into NSS, authenticate using PAM and create home directory with pam_mkhomedir.so and then possibly lookup the user’s public key.</strong></blockquote><p name="5cc8" id="5cc8" class="graf graf--p graf-after--blockquote">And three days down, we solved the first problem — a system which allows Linux servers to lookup user using <em class="markup--em markup--p-em">nss_switch</em>. Our <a href="https://giuthub.com/gate-sso/nss_gate" data-href="https://giuthub.com/gate-sso/nss_gate" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener" target="_blank">https://github.com/gate-sso/nss_gate</a> module provided exactly that, and then combined with <a href="https://github.com/gate-sso/pam_gate" data-href="https://github.com/gate-sso/pam_gate" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener" target="_blank">https://github.com/gate-sso/pam_gate</a> module, we could authenticate a user and then if password authentication was to be bypassed then <em class="markup--em markup--p-em">sshd_config</em> will use AuthorizedKeysCommand to lookup the key at Gate server and let the user log in.</p><p name="5c22" id="5c22" class="graf graf--p graf-after--p">This allows a user to login to any system, as long as they have access to Gate. This wasn’t ideal; we wanted to make sure that Gate’s users are not given access to any arbitrary system but only to system that they were supposed to login to. This could be controlled at two places:</p><ol class="postList"><li name="71eb" id="71eb" class="graf graf--li graf-after--p">PAM module should not authenticate if user is not authorized to login to the box</li><li name="6eab" id="6eab" class="graf graf--li graf-after--li">AuthorizedKeysCommand should not return appropriate key if user is not authorized to login to the box.</li></ol><h4 name="8156" id="8156" class="graf graf--h4 graf-after--li">So how do you restrict a user login to a server?</h4><p name="5b6e" id="5b6e" class="graf graf--p graf-after--h4">Pattern matching for IP address and host name was the way to go forward, given that we record user specific host names per user. Since some servers can be behind a single firewall, we supplied the IP address from PAM and AuthorizedKeysCommand — and then we could check that against our patterns file.</p><p name="45f2" id="45f2" class="graf graf--p graf-after--p">For example, if all the staging boxes are named as s-* then adding a host pattern of <em class="markup--em markup--p-em">s-*</em> will allow users to specific hosts whose name is s-*. Or, you can match IP address as well. Given this, now we could control users in following way:</p><ol class="postList"><li name="5dbe" id="5dbe" class="graf graf--li graf-after--p">Check if user is active, else fail authentication across board</li><li name="7059" id="7059" class="graf graf--li graf-after--li">Check if user has pattern matching with host name then allow access</li><li name="4924" id="4924" class="graf graf--li graf-after--li">Check if user has pattern matching with IP Address then allow access</li></ol><p name="45a6" id="45a6" class="graf graf--p graf-after--li">Now given this, we could make sure that users access only authorized systems and have a central place to manage access. We could also just disable users on Gate’s UI, to ensure that they wouldn’t be able to have access to our VPN service, internal portals, SaaS services which allow SAML login (jira, confluence etc) and Linux boxes!</p><p name="5e51" id="5e51" class="graf graf--p graf-after--p">And that’s how Gate-SSO — A rest based SSO server coupled with CAS and MFA is now key to any access within Go-Jek.</p><p name="5cb5" id="5cb5" class="graf graf--p graf-after--p">For more information on Gate, please checkout <a href="https://gate-sso.github.io/" data-href="https://gate-sso.github.io/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://gate-sso.github.io</a> or <a href="https://github.com/gate-sso" data-href="https://github.com/gate-sso" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/gate-sso</a> for all module details. If you want to add features to gate, please create a fork and send us the pull request!</p><p name="6a2f" id="6a2f" class="graf graf--p graf-after--p">The good news is that this implementation saved around 40 hours of user management effort every week at Go-Jek and we implemented everything in 6 days.</p><h4 name="7921" id="7921" class="graf graf--h4 graf-after--p">The Build Vs Buy debate</h4><p name="974d" id="974d" class="graf graf--p graf-after--h4">On hindsight, we debated a lot about the need to build something like this, as opposed to purchasing an off the shelf system, as there are many out there.</p><p name="b87b" id="b87b" class="graf graf--p graf-after--p">But we learnt that sometimes, if you start building things that complement each other, on top of these simple implementations — you are likely to end up with something pretty significant.</p><p name="e87f" id="e87f" class="graf graf--p graf-after--p">There is always an argument around build vs buy, in today’s SaaS heavy world. In most cases, it is better value to buy rather than build; but sometimes we take this argument to the extreme and end up paying for pretty small things. As a result, our developers start forgetting how the basic building blocks for the internet work. Again, the argument is that in the connected world you just purchase small services and put them together to work for you. And this is perfectly fine given the multiple choices we have today. But there is a need to balance learning vs leaning on something else, build vs buy another service or host it yourself vs cloud based solution. Given the complexity and scale we deal with at Go-Jek, I think it’s very important to have that balance a bit skewed towards build.<strong class="markup--strong markup--p-strong"> </strong>Having said that, it’s important to build it right, and always coupled with strategic thinking.</p><p name="414b" id="414b" class="graf graf--p graf-after--p">Once we start implementing this thought process, we end up creating a balanced software ecosystem with smart choices around it — those choices end up creating a better trusted and stable deployment ecosystem for you and your team.</p><p name="9a4e" id="9a4e" class="graf graf--p graf-after--p">So, the next time, when someone says, let’s just use SNS, say to them: “Why don’t you ‘assemble’ an SMTP service with SPF records and TLS?” and see if they give it a shot. You might not end up using it, but at least they will know how it works!</p><h4 name="ed50" id="ed50" class="graf graf--h4 graf-after--p">About Author</h4><figure name="cddf" id="cddf" class="graf graf--figure graf--layoutOutsetLeft graf-after--h4"><img class="graf-image" data-image-id="1*sRq6kxVuhym8Mh9JCNPxqA.png" data-width="250" data-height="250" src="https://cdn-images-1.medium.com/max/600/1*sRq6kxVuhym8Mh9JCNPxqA.png"><figcaption class="imageCaption">Ajey Gore (Go-Jek CTO)</figcaption></figure><p name="1a4d" id="1a4d" class="graf graf--p graf-after--figure graf--trailing">With 17 years of experience in building core technology strategy across diverse domains, Ajey has helped several businesses through technology transformations @ Thoughtworks and CodeIgnition.<br>Ajey is the founder of Codeingnition and an active influencer in the technology community.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ajeygore" class="p-author h-card">Ajey Gore</a> on <a href="https://medium.com/p/6b57b6f11597"><time class="dt-published" datetime="2017-02-01T07:40:26.158Z">February 1, 2017</time></a>.</p><p><a href="https://medium.com/@ajeygore/how-vpn-automation-ended-up-becoming-a-single-sign-on-server-part-2-6b57b6f11597" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on May 30, 2021.</p></footer></article></body></html>