---
permalink: /tuning-performance-with-java-on-linux-systems/index.html
layout: post
title: Tuning performance with Java - on Linux systems
published: true
categories: []
---

<p>
<p><span style="font-family: Arial;">I love java, rather jvm - well, as technology and have been making use of it. Java world is full of rock solid implementations about technologies and have a huge software library eco system to deliver things with rock solid performance. It also makes a very good candidate for dependable technology.</span></p>
<p><span style="font-family: Arial;">Recently, we choose java at backend for everything we do in ruby :-) So everything ruby becomes everything java at the backend. There are many advantages of this approach - a nice language to work with (ruby) and nice dependable technology at production environment (jvm) - in short, we use jruby with torquebox. But there are caveats and as its true with every tool - "if you didn't use it right, it won't give you right results"</span></p>
<p><span style="font-family: Arial;">When check-in rush happened last week at hoppr - it melted our servers to levels of not able to breath within given time frame. Our code looked right, we were doing everything right and making sure that our code is well optimized for what ever we can - although we had to make some changes to our code the way we look up db entries and other information, but that did not help at all for making service perform to the levels we wanted. We did not have enough time to react because service would go down pretty frequently &ndash; we started investigating to figure out what&rsquo;s causing it.</span></p>
<p><strong><span style="font-family: Arial;">The first culprit - memory</span></strong></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;">&nbsp;</span><span style="font-family: Arial;">At prima facie it looked like we were running out of memory, well its true and it was true &ndash; and the easiest way to deal with it to add more ram. Unfortunately we did not have that option, we had to make service work within limited memory and make sure that it does not go out of memory.</span></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;">&ldquo;Out of memory&rdquo; error occurs for several reasons &ndash;</span></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;">We increased limits for user processes and open file &ndash; since everything is file in linux including sockets and tends towards memory allocation, but that did not solve the problems we had 1000s of open sockets and still it would cause it to get out of memory.</span></p>
<p><strong><span style="font-family: Arial;">The secon cultprit - network protocol</span></strong></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;">Next tuning was around fixing networking parameters &ndash; like decrease FIN_WAIT, TIME_WAIT parameters to 5 seconds, we then added options to recycle sockets, increased WMEM and RMEM parameters to use large data size to transporting data &ndash; so that with one socket connection we can send upto 640kb data &ndash; which resulted in less round trips</span></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;">Using big pages was another tuning which we had to implement so that we can take advantage of java using big memory pages instead of smaller ones and perform better.</span></p>
<p><strong><span style="font-family: Arial;">The third culprit - defaults in app container</span></strong></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;">When we were done with OS level settings, we turned towards torquebox and found many things which could be fixed &ndash; we increased thread pools, put threads execution times within 3 seconds (since we had to complete processing within 200ms) and thread wait to max 5 seconds.</span></p>
<p><strong>The fourth culprit - default jvms gc</strong></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;">Lastly we looked at JVM itself &ndash; if you do have multiple cores and huge memory &ndash; then set &ndash;Xms and &ndash;mXM to same value &ndash; so JVM does not have to struggle to allocate memory, since we knew that its going to consume that much, we should have done that earlier. GC also plays a huge part in it and we ran GC every 15 minutes instead of every hour, made it run parallel and allocated 25% CPU to it &ndash; that way we ensured that we collected what ever we littered in last 15 minutes &ndash; we do a lot of check-ins and most probably they did not need to dangle around for an hour.</span></p>
<p style="padding-left: 30px;"><span style="font-family: Arial;"><br /></span></p>
<p><span style="font-family: Arial;">In summary, The learning was fun &ndash; it required reading a lot of core-dumps, jmx monitoring and looking at threads very carefully, but solved our problems and hopefully we will be able to scale better.</span></p>
<p><span style="font-family: Arial;">The default settings are pretty relaxed in OS and JVM. But these settings won&rsquo;t always work for everyone, the bigger learning was that adding more cpu and memory will not solve a problem. We know that our existing system still has limits &ndash; to how many check-ins we can handle per hour, but at least now we know that what works when&hellip;</span></p>
<p><span style="font-family: Arial;"><br /></span></p>
<p>&nbsp;</p>
</p>

<p>&nbsp;</p>
